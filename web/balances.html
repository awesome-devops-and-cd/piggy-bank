<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css">
  <title>Piggy Bank - Balances</title>
  <style>
    body {
      padding: 50px;
    }

    legend {
      font-size: xx-large;
      padding-bottom: 50px;
    }

    summary {
      position: relative;
    }

    summary code {
      position: absolute;
      right: 60px;
      padding: 4px;
    }

    .negative {
      background-color: indianred;
      color: white;
    }

    .positive {
      background-color: lightgreen;
      color: black;
    }
  </style>
</head>

<body>
  <a href="index.html">‹ Back</a>
  <br>
  <br>
  <article id="users">
    Loading...
  </article>
  <article>
    <h4>Recommended operations to settle debts</h4>
    <ul id="ul-track-op">
    </ul>
  </article>

  <script>
    fetch('api/expenses.json', {
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const credit = computeCreditBalance(data)
        const debit = computeDebitBalance(data)
        const userList = uniqueUsers(...Object.keys(credit), ...Object.keys(debit))
        const balances = computeBalances(userList, credit, debit)

        const usersElement = document.getElementById('users')
        const userFragment = document.createDocumentFragment()

        userList.forEach(user => {
          const details = document.createElement('details')
          details.appendChild(balanceUserSummary(user, balances[user].balance))
          details.appendChild(balanceListHeader('Credits'))
          details.appendChild(balanceList(balances[user].credit, '+'))
          details.appendChild(balanceListHeader('Debits'))
          details.appendChild(balanceList(balances[user].debit, '-'))
          userFragment.appendChild(details)
        })

        users.replaceChildren(userFragment)

        // #######################################

        // Remove from the balances the user with balance 0

        function filterZeroBalances(array) {
          return array.filter(innerArray => innerArray[1] !== 0);
        }

        // Sort the array based on the second element
        function SortBalances(array) {
          return array.sort(function (first, second) {
            return Math.abs(first[1]) - Math.abs(second[1]);
          })
        }

        var items = userList.reduce((items, user) => [...items, [user, balances[user].balance]], [])

        items = filterZeroBalances(items)
        items = SortBalances(items)

        var ul = document.getElementById("ul-track-op");

        while (items.length) {

          for (j = 1; j < items.length; j++) {
            if (items[0][1] * items[j][1] < 0) {

              items[j][1] += items[0][1]

              // create the steps for the UI
              if (items[0][1] < 0) {
                const ul = document.getElementById("ul-track-op");
                const li = document.createElement("li");
                li.appendChild(document.createTextNode(items[0][0] + " should give " + items[j][0] + " €" + Math.abs(items[0][1])));
                ul.appendChild(li);
              } else {
                const ul = document.getElementById("ul-track-op");
                const li = document.createElement("li");
                li.appendChild(document.createTextNode(items[j][0] + " should give " + items[0][0] + " €" + Math.abs(items[0][1])));
                ul.appendChild(li);
              }

              //compute the new balances
              items[0][1] = 0;
              break;
            }
          }

          items = filterZeroBalances(items)
          items = SortBalances(items)
        }


        // #######################################
      })

    function uniqueUsers(...users) {
      return [...new Set(users)]
    }

    function balanceUserSummary(username, balance) {
      const summary = document.createElement('summary')
      const classColor = balance >= 0 ? 'positive' : 'negative'
      summary.innerHTML = `${username} <code class="${classColor}">${balance}€</code>`

      return summary
    }

    function balanceListHeader(title) {
      const header = document.createElement('h4')
      header.innerText = title
      return header
    }

    function balanceList(dictionary, prefix) {
      const list = document.createElement('ul')

      Object.keys(dictionary).forEach(user => {
        const listItem = document.createElement('li')
        listItem.innerHTML = `${user} ${prefix}${dictionary[user]}€`

        list.appendChild(listItem)
      })

      return list
    }


    function computeBalances(users, credit, debit) {
      return users.reduce(toDebitAndCreditBalancesByUser, {})

      function toDebitAndCreditBalancesByUser(balances, user) {
        const userCredit = credit[user] || {}
        const userDebit = debit[user] || {}
        balances[user] = {
          credit: userCredit,
          debit: userDebit,
          balance: sumValues(userCredit) - sumValues(userDebit)
        }

        return balances
      }

      function sumValues(object) {
        return Object.values(object).reduce((sum, number) => (sum + number), 0)
      }
    }

    function computeDebitBalance(transactions = []) {
      return transactions.reduce(toDebitBalancesByUser, {} /* users */)

      function toDebitBalancesByUser(users, transaction) {
        const { username, amount, participants } = transaction
        const equalShare = amount / participants.length

        participants
          .filter(participant => participant !== username)
          .forEach(participant => {
            if (!users[participant]) users[participant] = {}
            if (!users[participant][username]) users[participant][username] = 0
            users[participant][username] += equalShare
          })

        return users
      }
    }

    function computeCreditBalance(transactions = []) {
      return transactions.reduce(toCreditBalancesByUser, {})

      function toCreditBalancesByUser(users, { username, amount, participants }) {
        const equalShare = amount / participants.length
        participants
          .filter(participant => participant !== username)
          .forEach(participant => {
            if (!users[username]) users[username] = {}
            if (!users[username][participant]) users[username][participant] = 0
            users[username][participant] += equalShare
          })

        return users
      }

    }

  </script>
</body>

</html>
